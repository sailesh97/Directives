<div class="container">
  <div class="row">
    <div class="col-xs-12">
      <button
        class="btn btn-primary"
        (click)="onlyOdd = !onlyOdd">Only show odd numbers</button>
      <br><br>
      <ul class="list-group">
        <div *ngIf = "onlyOdd">
          <li
          
          class="list-group-item"
          *ngFor="let odd of oddNumbers"
          [ngClass]="{odd: odd % 2 !== 0}"
          [ngStyle]="{backgroundColor: odd % 2 != 0 ? 'yellow' : transparent}"
          >
          {{ odd }}
          </li>
        </div>
        <div *ngIf = "!onlyOdd">
          <li
          class="list-group-item"
          *ngFor="let even of evenNumbers"
          [ngClass]="{odd: even % 2 !== 0}"
          >
          {{ even }}
        </li>
        </div>
      </ul>
      <!-- <appBasicHighlight> Style me with directive </appBasicHighlight> -->
      <p appBasicHighlight> Style me with directive </p>
      <!-- <p appBetterHighlight [defaultColor]="'yellow'" [highlightColor]="'red'"> Style me with better directive </p> -->

      <!-- Another Syntax of property binding -->
      <!-- <p appBetterHighlight defaultColor="yellow" highlightColor="red"> Style me with better directive </p> -->
      
      <p [appBetterHighlight]="'red'" defaultColor="yellow" > Style me with better directive </p>
      <!-- 
        Two interesting things to observe:
        i. Here we pass two extra attribute looking values. Which are properties of the directive we have used and not the properties of the paragraph.
        So how does Angular know which is a native paragraph attribute and which is not. or a property of the directive. 
        The answer is: it just figures that out. It simply just checks our custom directives and hence knows about their properties 1st before it reaches the native HTML attributes.

        ii. So, we can bind to properties of our own directive( defaultColor here), by placing them on same element and wrapping with [].
        In ngClass which is a built-in directive the directive itself is enclosed in [].

        That's a typical usecase where your directive has only one property or atleast one main property in it.
        In that scenario you can use an alias(same as your directive selector)

        It's optional if you want you can use two different names for directive Name and your property name
        Or you can use the same name for both. 

        That's the reason why we wrapped ngClass with [] and not wrapped appBetterHighlight (at first).
        Because by wrapping [] in ngClass we're binding to ngClass property of the ngClass directive.

        We could achieve the same behaviour for appBetterHighlight by using alias name. We have also seen how to maintain separate names for directive name and main property name of the directive.
      -->
    </div>
  </div>
</div>

<!-- 

  ngClass is a directive

  [ngClass]= "{cssClassName: any statement/method/conditon that resolves to a boolean value }"

  The square bracket around ngClass here denotes that we're binding to some property on our ngClass directive.

  ngClass expects an object (within double quotes), where the key is the css class name and it's value is a Javascript statement, method or anything that at the end resolves to a boolean value.

 -->

 <!--

  ngStyle is another in-built directive.

  Syntax: [ngStyle] = "{backgroundColor: odd % 2 !== 0 ? 'yellow' : 'transparent'}"

  ngStyle also expects an object (within double quotes), where the key is an css style property and like ngClass it's value can also be set dynamically through a function call, or Javascript statement
  and the value depends on what css style property you have used. Here a string (that's a color value).
   
 -->